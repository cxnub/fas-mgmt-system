// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: schemes.sql

package pg

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createScheme = `-- name: CreateScheme :one
INSERT INTO schemes (
    id,
    created_at,
    name
) VALUES (
            gen_random_uuid(), now(), $1
         )
RETURNING id, created_at, updated_at, deleted_at, name
`

// Used for POST /api/schemes
func (q *Queries) CreateScheme(ctx context.Context, name string) (Scheme, error) {
	row := q.db.QueryRow(ctx, createScheme, name)
	var i Scheme
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
	)
	return i, err
}

const deleteScheme = `-- name: DeleteScheme :exec
UPDATE schemes
SET
    deleted_at = now()
WHERE id = $1 AND deleted_at IS NULL
`

// Used for DELETE /api/schemes/{id}
func (q *Queries) DeleteScheme(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteScheme, id)
	return err
}

const getScheme = `-- name: GetScheme :one

SELECT id, created_at, updated_at, deleted_at, name FROM schemes
WHERE id = $1 AND deleted_at IS NULL
`

// db/query/schemes.sql
// Used for GET /api/schemes/{id}
func (q *Queries) GetScheme(ctx context.Context, id uuid.UUID) (Scheme, error) {
	row := q.db.QueryRow(ctx, getScheme, id)
	var i Scheme
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
	)
	return i, err
}

const getSchemeWithBenefits = `-- name: GetSchemeWithBenefits :many
SELECT
    s.id, s.created_at, s.updated_at, s.deleted_at, s.name,
    b.id as benefit_id,
    b.name as benefit_name,
    b.amount as benefit_amount
FROM schemes s
         LEFT JOIN benefits b ON s.id = b.scheme_id AND b.deleted_at IS NULL
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type GetSchemeWithBenefitsRow struct {
	ID            uuid.UUID
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	DeletedAt     pgtype.Timestamp
	Name          string
	BenefitID     pgtype.UUID
	BenefitName   pgtype.Text
	BenefitAmount pgtype.Float8
}

// Used for getting a scheme with its benefits
func (q *Queries) GetSchemeWithBenefits(ctx context.Context, id uuid.UUID) ([]GetSchemeWithBenefitsRow, error) {
	rows, err := q.db.Query(ctx, getSchemeWithBenefits, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchemeWithBenefitsRow
	for rows.Next() {
		var i GetSchemeWithBenefitsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.BenefitID,
			&i.BenefitName,
			&i.BenefitAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchemeWithCriteriaAndBenefits = `-- name: GetSchemeWithCriteriaAndBenefits :many
SELECT
    s.id, s.created_at, s.updated_at, s.deleted_at, s.name,
    sc.id as criteria_id,
    sc.name as criteria_name,
    sc.value as criteria_value
FROM schemes s
         LEFT JOIN scheme_criteria sc ON s.id = sc.scheme_id AND sc.deleted_at IS NULL
WHERE s.id = $1 AND s.deleted_at IS NULL
`

type GetSchemeWithCriteriaAndBenefitsRow struct {
	ID            uuid.UUID
	CreatedAt     pgtype.Timestamp
	UpdatedAt     pgtype.Timestamp
	DeletedAt     pgtype.Timestamp
	Name          string
	CriteriaID    pgtype.UUID
	CriteriaName  pgtype.Text
	CriteriaValue pgtype.Text
}

// Used for getting a scheme with its criteria
func (q *Queries) GetSchemeWithCriteriaAndBenefits(ctx context.Context, id uuid.UUID) ([]GetSchemeWithCriteriaAndBenefitsRow, error) {
	rows, err := q.db.Query(ctx, getSchemeWithCriteriaAndBenefits, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSchemeWithCriteriaAndBenefitsRow
	for rows.Next() {
		var i GetSchemeWithCriteriaAndBenefitsRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
			&i.CriteriaID,
			&i.CriteriaName,
			&i.CriteriaValue,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSchemes = `-- name: ListSchemes :many
SELECT id, created_at, updated_at, deleted_at, name FROM schemes
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

// Used for GET /api/schemes
func (q *Queries) ListSchemes(ctx context.Context) ([]Scheme, error) {
	rows, err := q.db.Query(ctx, listSchemes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Scheme
	for rows.Next() {
		var i Scheme
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateScheme = `-- name: UpdateScheme :one
UPDATE schemes
SET
    name = $2
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, created_at, updated_at, deleted_at, name
`

type UpdateSchemeParams struct {
	ID   uuid.UUID
	Name string
}

// Used for PUT /api/schemes/{id}
func (q *Queries) UpdateScheme(ctx context.Context, arg UpdateSchemeParams) (Scheme, error) {
	row := q.db.QueryRow(ctx, updateScheme, arg.ID, arg.Name)
	var i Scheme
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Name,
	)
	return i, err
}
